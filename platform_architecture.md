# Архитектура Корпоративной Платформы ИИ-агентов


- [1. Принципы построения](#1-принципы-построения)
- [2. Функциональные зоны](#2-функциональные-зоны)
- [3. Ключевые архитектурные решения](#3-ключевые-архитектурные-решения)
- [4. Нефункциональные требования](#4-нефункциональные-требования)
- [5. Диаграммы](#5-диаграммы)


## 1. Принципы построения

Платформа строится на основе следующих ключевых принципов, обеспечивающих ее гибкость, масштабируемость и готовность к созданию автономных ИИ-организаций:

-   **LangGraph-Native Core**: Вся логика работы агентов, их взаимодействие и управление состоянием строятся на базе LangGraph. Это позволяет использовать самые современные подходы к созданию мульти-агентных систем, включая циклы, ветвления и персистентность состояния "из коробки".

-   **Событийно-ориентированная архитектура (Event-Driven)**: Все взаимодействия внутри системы, от запроса пользователя до выполнения задачи агентом, являются событиями, проходящими через брокер сообщений Kafka. Это полностью разделяет компоненты системы (агентов, сервисы, интерфейсы), позволяя им работать независимо и асинхронно.

-   **Database-First & Configuration as Data**: Конфигурация агентов, флоу и инструментов хранится в базе данных. Код определяет только *поведение* (логику), но не *структуру*. Это позволяет изменять и настраивать агентов на лету без перезагрузки сервисов, что критично для автономных систем.

-   **Расширяемость через Agent Development Kit (ADK)**: Платформа предоставляет четкий и простой API для разработчиков (ADK) для создания новых агентов и инструментов. ADK инкапсулирует сложность взаимодействия с ядром LangGraph и брокером сообщений, позволяя разработчикам фокусироваться на бизнес-логике.

-   **Наблюдаемость (Observability)**: Каждый шаг выполнения агента, каждое событие и изменение состояния трассируется и логируется. Это обеспечивает полную прозрачность работы системы, что необходимо для отладки, мониторинга и анализа поведения автономных агентов.

-   **Единообразие интерфейсов**: Все агенты, независимо от их сложности и вложенности, имеют единый интерфейс взаимодействия. Агент-супервизор работает с субагентом так же, как и с обычным инструментом (`as_tool`), что позволяет строить иерархии любой глубины.

## 2. Функциональные зоны

Платформа логически разделена на несколько функциональных зон, каждая из которых отвечает за свой аспект работы системы.

-   **Agent Core (Ядро агентов)**:
    -   **Исполнитель (Executor) на базе LangGraph**: Отвечает за компиляцию и выполнение графов агентов. Ядро полностью построено на возможностях LangGraph.
    -   **Фабрики (Factories)**: `AgentFactory`, `FlowFactory`, `ToolFactory` - ключевые компоненты, которые на основе конфигурации из БД собирают "живые" экземпляры агентов, графов и инструментов со всеми зависимостями. Они являются мостом между конфигурацией в БД и исполняемым кодом.

-   **Orchestration Layer (Слой оркестрации)**:
    -   **Брокер сообщений (Kafka)**: Центральная шина для всех событий в системе. Заменяет прямые вызовы и `TaskRepository`. Обеспечивает отказоустойчивость и асинхронность.
    -   **Воркеры (Taskiq)**: Асинхронные обработчики задач, которые подписываются на топики Kafka. Они получают задания, вызывают соответствующий Agent Core для их выполнения и отправляют результат обратно в Kafka.

-   **Communication Layer (Слой коммуникации)**:
    -   **Внешние интерфейсы (Interfaces)**: Адаптеры для различных каналов (Telegram, Web Sockets, API). Они принимают запросы от пользователей, преобразуют их в стандартные события и отправляют в Kafka. Также они слушают Kafka для получения ответов и отправки их пользователям.
    -   **A2A API (Agent-to-Agent)**: Стандартизированный протокол для прямого асинхронного взаимодействия между агентами через Kafka. Позволяет одному агенту вызывать другой, передавать ему задачи и получать результаты.
    -   **Предобработка данных**: Интерфейсы отвечают не только за транспорт, но и за первичную обработку входящих данных. Например, при получении аудио-сообщения или файла, интерфейс скачивает его, передает в соответствующий сервис (`AudioProcessor`, `FileProcessor`), а агенту в Kafka отправляется уже текстовая транскрипция и/или ID сохраненного файла. Это позволяет агентам работать с унифицированными текстовыми данными.

-   **Development Kit & Tooling (ADK)**:
    -   **BaseAgent и декораторы**: Набор базовых классов и утилит, упрощающих создание новых агентов и инструментов.
    -   **CLI и утилиты**: Инструменты для разработчиков для миграции, тестирования и отладки агентов.

-   **State & Memory Layer (Слой состояния и памяти)**:
    -   **Checkpointer**: Стандартный механизм LangGraph для сохранения и восстановления состояния графа (например, в Redis или Postgres). Обеспечивает персистентность диалогов и возможность возобновления работы с прерванного места.
    -   **Общая память (Shared Memory)**: Долгосрочная память и база знаний (например, векторная база данных), доступная всем агентам для хранения и извлечения информации.

## 3. Ключевые архитектурные решения

### 3.1. LangGraph как ядро агентов

Ядром платформы является **LangGraph**. Все агенты, от простых исполнителей до сложных супервизоров, представляют собой скомпилированные графы LangGraph.

-   **Иерархия агентов**: Реализуется через механизм `as_tool`. Любой агент может быть "обернут" и представлен как инструмент для другого, вышестоящего агента. Это позволяет строить вложенные команды агентов (`Team`) и сложные иерархии, где супервизоры делегируют задачи субагентам.

-   **Динамическое возобновление (Interrupt Handling)**: Это ключевая особенность для интерактивного взаимодействия. Когда вложенному агенту требуется информация от пользователя, он вызывает `GraphInterrupt`.
    -   Прерывание "всплывает" вверх по стеку вызовов до Communication Layer.
    -   Система сохраняет полный state графа (включая ID прервавшегося агента) с помощью `checkpointer`.
    -   Сообщение отправляется пользователю.
    -   Когда пользователь отвечает, Communication Layer находит сохраненный state и направляет ответ напрямую в **прерванный узел графа**, а не начинает весь процесс заново с агента-роутера. Это обеспечивает бесшовное продолжение диалога именно с тем агентом, который задал вопрос.

-   **Управление состоянием (State Management)**: Используется единый объект `State` (TypedDict), который передается по всему графу. Он содержит `messages`, `store` (общая память для данных) и другие служебные поля. `Checkpointer` автоматически сохраняет этот `State` после каждого шага, обеспечивая отказоустойчивость.

### 3.2. Kafka и Taskiq для асинхронной оркестрации

Для управления жизненным циклом задач используется связка **Kafka + Taskiq**.

-   **Топики Kafka**:
    -   `tasks.in`: Входящие задачи от пользователей и других систем. Сюда пишут Communication Layer и A2A API.
    -   `tasks.out`: Результаты выполнения задач. Их слушает Communication Layer (для отправки пользователям) и другие агенты (в рамках A2A).
    -   `agent.events`: Служебные события для мониторинга и наблюдаемости (старт/конец задачи, вызов инструмента, ошибка).

-   **Воркеры Taskiq**:
    -   **Обработка задач**: Основная роль воркеров — подписываться на топик `tasks.in`, обрабатывать задачи с помощью `Agent Core` и публиковать результаты в `tasks.out`.
    -   **Периодические системные задачи**: `Taskiq` также используется для запуска регулярных фоновых задач (аналогично cron), таких как синхронизация данных с внешними системами (MCP), очистка старых сессий, синхронизация платежей и т.д. Это заменяет логику, ранее находившуюся в `lifespan.py`, и унифицирует выполнение всех фоновых процессов.

### 3.3. Agent Development Kit (ADK) и Фабрики

ADK — это API и набор инструментов, предоставляемый платформой для упрощения разработки, конфигурации и развертывания агентов.

-   **`BaseAgent`**: Абстрактный класс, от которого наследуются все агенты. Он содержит базовую логику компиляции графа и вызова (`ainvoke`).
-   **Фабрики (`AgentFactory`, `FlowFactory`, `ToolFactory`)**: Являются центральным элементом. Они инкапсулируют логику сборки агентов из конфигурации в БД. Разработчику не нужно вручную создавать экземпляры, он просто описывает конфигурацию, а фабрика сама собирает готовый к работе объект со всеми зависимостями (LLM, тулы, субагенты).
-   **Декораторы (`@tool`)**: Упрощают создание инструментов, автоматически добавляя сериализацию, валидацию и метаданные для биллинга.
-   **Мигратор (Migrator)**: Ключевой компонент ADK, который реализует принцип "Code as Source of Truth". При старте приложения или по команде, мигратор сканирует кодовую базу, находит классы агентов и функции-инструменты, и на их основе автоматически создает или обновляет соответствующие конфигурации в базе данных. Это позволяет разработчикам определять агентов декларативно в коде, а платформа сама делает их доступными для использования через API и UI.

### 3.4. Agent-to-Agent (A2A) API

A2A API — это внутренний протокол, позволяющий агентам асинхронно взаимодействовать друг с другом через Kafka.

-   **Принцип работы**: Если Агент А хочет вызвать Агента Б, он не импортирует его код напрямую. Вместо этого, Агент А формирует стандартное сообщение-задачу (с указанием `agent_id='Б'`, входными данными и `callback_topic`) и отправляет его в топик `tasks.in`.
-   **Получение результата**: Агент А может либо ждать ответ в специальном `callback_topic`, либо продолжить свою работу и получить результат позже. Это обеспечивает слабую связанность и высокую параллельность работы агентов.

### 3.5. Google ADK-совместимый A2A-интерфейс: Flow как точка входа

Центральным понятием в A2A API является **"Flow"** (Поток). В контексте нашей платформы, Flow — это публично доступная **точка входа** в определенный бизнес-процесс, реализованный с помощью одного или нескольких агентов. Каждый `flow_id` однозначно идентифицирует корневой агент (супервизор), с которого начинается выполнение задачи.

Для обеспечения нативной интеграции с внешней экосистемой AI-агентов, платформа реализует публичный интерфейс, полностью совместимый со спецификацией **Google Agent-to-Agent (A2A)**. Это позволяет любому клиенту или агенту, использующему Google Agent Development Kit (ADK), бесшовно взаимодействовать с агентами нашей платформы.

-   **"Карточка Агента" (Agent Card)**:
    -   Каждый `flow`, помеченный как публичный, автоматически предоставляет "карточку агента" — стандартизированный `JSON` файл.
    -   Эта карточка доступна по публичному URL: `GET /flows/{flow_id}/.well-known/agent-card.json`.
    -   Она содержит всю мета-информацию, необходимую для взаимодействия: описание агента, эндпоинты API, схемы данных (`OpenAPI Schema`) для запросов и ответов.

-   **Аутентификация**: Взаимодействие защищено стандартными механизмами, такими как OAuth 2.0 или API-ключи, как это определено в спецификации Google.

-   **Асинхронный флоу**:
    1.  Внешний ADK-клиент (`RemoteA2aAgent`) считывает `agent-card.json`, чтобы понять, как общаться с нашим агентом.
    2.  Клиент отправляет `POST` запрос на эндпоинт `/invoke`.
    3.  Наш Communication Layer принимает запрос, валидирует его и публикует задачу в Kafka (`tasks.in`), немедленно возвращая `task_id`.
    4.  Дальнейшее получение результата происходит асинхронно через **вебхуки** или **длительные опросы (long polling)**, как это принято в спецификации A2A, вместо простого polling'а. Это обеспечивает более эффективное и нативное взаимодействие для внешних систем.

## 4. Нефункциональные требования

-   **Масштабируемость**: Архитектура на базе Kafka и Taskiq позволяет горизонтально масштабировать количество обработчиков (воркеров) для обработки растущего числа задач. Каждый компонент (интерфейсы, воркеры, сервисы) является stateless и может быть запущен в нескольких экземплярах.

-   **Отказоустойчивость**: Kafka обеспечивает гарантированную доставку сообщений. Если воркер падает во время обработки задачи, сообщение не теряется и будет обработано другим воркером. `Checkpointer` в LangGraph обеспечивает возможность восстановления состояния агента после сбоя.

-   **Безопасность**: Все внешние API-запросы проходят через шлюз с аутентификацией и авторизацией. Для A2A взаимодействия используются внутренние механизмы аутентификации Kafka. Конфигурации и чувствительные данные хранятся в зашифрованном виде.

-   **Производительность**: Асинхронная обработка и слабая связанность компонентов минимизируют задержки. Использование эффективных брокеров сообщений и асинхронных фреймворков (FastAPI, Taskiq) обеспечивает высокую пропускную способность.

-   **Конфигурируемость**: Благодаря подходу "Configuration as Data", поведение системы можно гибко изменять через обновление конфигураций в БД без необходимости переразвертывания кода.

## 5. Диаграммы

### 5.1. Общая архитектура системы

```mermaid
graph TD
    subgraph User Interfaces
        UI[External Clients: Web, Telegram, API]
    end

    subgraph Communication Layer
        direction LR
        Comm_In[Inbound Adapters]
        Comm_Out[Outbound Adapters]
    end

    subgraph Orchestration Layer
        direction TB
        Kafka(Kafka Bus)
        Taskiq[Taskiq Workers]
    end

    subgraph Agent Core
        direction TB
        Factories[Factories: Agent, Flow, Tool]
        Executor[LangGraph Executor]
    end

    subgraph Data & State
        direction LR
        DB[(Configuration DB)]
        Checkpointer[(State Checkpointer: Redis)]
    end

    UI -- HTTP/WS --> Comm_In
    Comm_In -- Publishes Task --> Kafka
    Kafka -- Consumes Task --> Taskiq
    Taskiq -- Requests Agent --> Factories
    Factories -- Reads Config --> DB
    Factories -- Builds Agent --> Executor
    Executor -- Runs Graph --> Executor
    Executor -- Persists State --> Checkpointer
    Executor -- Returns Result --> Taskiq
    Taskiq -- Publishes Result --> Kafka
    Kafka -- Consumes Result --> Comm_Out
    Comm_Out -- Sends Reply --> UI
```

### 5.2. Жизненный цикл задачи (с Interrupt)

```mermaid
sequenceDiagram
    participant User
    participant Interface
    participant Kafka
    participant Worker (Taskiq)
    participant Agent (LangGraph)
    participant Checkpointer

    User->>Interface: 1. Отправляет запрос
    Interface->>Kafka: 2. Публикует в tasks.in
    Kafka-->>Worker: 3. Доставляет задачу
    Worker->>Agent: 4. Вызывает ainvoke()
    Agent->>Agent: 5. Выполняет шаги графа
    Agent->>Checkpointer: 6. Сохраняет state после каждого шага
    Agent-->>Worker: 7. GraphInterrupt (нужен ввод)
    Worker->>Kafka: 8. Публикует Interrupt-ответ в tasks.out
    Kafka-->>Interface: 9. Доставляет ответ
    Interface-->>User: 10. Задает вопрос пользователю

    User->>Interface: 11. Отвечает на вопрос
    Interface->>Kafka: 12. Публикует ответ в tasks.in (с ID прерванного графа)
    Kafka-->>Worker: 13. Доставляет задачу
    Worker->>Checkpointer: 14. Загружает сохраненный state
    Worker->>Agent: 15. Возобновляет ainvoke() с нужного шага
    Agent->>Worker: 16. Возвращает финальный результат
    Worker->>Kafka: 17. Публикует результат в tasks.out
    Kafka-->>Interface: 18. Доставляет результат
    Interface-->>User: 19. Отправляет финальный ответ
```

### 5.3. Иерархия Агентов (Супервизор и Субагенты)

```mermaid
graph TD
    subgraph SupervisorAgent [Supervisor Agent Graph]
        S_Start(Start)
        S_Router{Router}
        S_Tool_A[Call SubAgent A as Tool]
        S_Tool_B[Call SubAgent B as Tool]
        S_End(End)
    end

    subgraph SubAgentA [SubAgent A Graph]
        A_Start(Start)
        A_Work(Do Work)
        A_End(End)
    end

    subgraph SubAgentB [SubAgent B Graph]
        B_Start(Start)
        B_Interrupt(Request User Input)
        B_End(End)
    end

    S_Start --> S_Router
    S_Router -- Route to A --> S_Tool_A
    S_Router -- Route to B --> S_Tool_B
    S_Tool_A --> S_End
    S_Tool_B --> S_End

    S_Tool_A -- Invokes --> A_Start --> A_Work --> A_End
    S_Tool_B -- Invokes --> B_Start --> B_Interrupt

    style SupervisorAgent fill:#f9f,stroke:#333,stroke-width:2px
    style SubAgentA fill:#ccf,stroke:#333,stroke-width:2px
    style SubAgentB fill:#ccf,stroke:#333,stroke-width:2px
```
